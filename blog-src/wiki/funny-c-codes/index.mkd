%title 趣味C代码片段
Date:2012-10-09

[TOC]

## 1.数组名不可以左值操作,但是..

在[segmentfault](http://segmentfault.com/q/1010000000120220)看到了一个问题.

代码如下:

```c
#include <stdio.h>
main(int argc, char const* argv[])
{
    char const* arr[]={"Hello","World","AndyXue"};
    *++argv;
    *++arr; 
}
```

运行结果

```
1.c: In function ‘main’:
1.c:6:6: error: lvalue required as increment operand
```
也就是:argv允许自增, 但是arr不可以 .

数组名是不可以做自增运算的, 但此处为何指针数组名argv可以自增呢?

因为, C语言中数组传入函数作为参数都是传的数组地址.此处argv只被认为成一个二维指针.

## 2.C不生成临时变量交换变量的值

两个方法:

```c
#include <stdio.h>
int main(int argc, const char *argv[])
{
	int a=1,b=2;
	a ^= b ^= a ^= b;
	printf( "%d%d", a, b );
	return 0;
}
```

```c
#include <stdio.h>
int main(int argc, const char *argv[])
{
	int a=1,b=2;
	a=a+b;
	b=a-b;
	a=a-b;
	printf( "%d%d", a, b );
	return 0;
}
```

## 3.数组名和数组下标可以互换

这个是老生常谈的了.以下代码可以顺利通过编译
```c
#include <stdio.h>
int main(int argc, const char *argv[])
{
	char arr[]="abcdef";
	printf( "%c",2[arr]);
	return 0;
}
```
因为a[b]被认为成*(a+b).所以2[arr]也是可以的.但是对于可读性没有好处

## 4.这段代码怎么通过编译的

```c
#include <stdio.h>
int main()
{
    http://www.shello.name/
    printf("haha!!\n");

    return 0;
}
```

解释如下: 

双斜杠之后是注释掉的.前面http:相当于一个goto的标签

## 5.sizeof不是一个函数

```c
#include <stdio.h>

main()
{
	int i = 0; 
	sizeof(i++); 
	printf("%d\n", i);
}
```

这里打印结果是0.i并没有自增.这说明sizeof不是个函数.

sizeof不是一个函数,而是一个操作符,求i++的类型的size，这是一件可以在程序运行前（编译时）就确定的事情，所以，sizeof(i++)直接就被4给取代了，在运行时也就不会有了i++这个表达式

## 6.试着理解下面的代码

```
#include <stdio.h>  
int main(int argc, const char *argv[])  
{  
	printf( "%d", ((int[]){1,2,3,4})[1] );  
	return 0;  
}   
```

把{1,2,3,4}强转成int[]形,再取数组{1,2,3,4}的下标为1的数

## 7.结构体对齐问题

```c
#include <stdio.h>  
int main(int argc, const char *argv[])  
{  
	struct foo1{  
		char c1;  
		int i;  
		char c2;  
	};  
	struct foo2{  
		int i;  
		char c1;  
		char c2;  
	};  
	printf("%d %d\n",sizeof(struct foo1),sizeof(struct foo2));  
	return 0;  
}  
```

执行结果是12 8

因为C中采用对齐的方式存储结构体.

```
foo1中是这么存储的:

c1 (跟int i对齐,由1扩展为4)

i sizeof取值得4

c2 (跟int i对齐,由1扩展为4)

---------------------------------------------------------------

foo2中是这么存储的:

i sizeof取值得4

c1,c2连续存储,并由2扩展为4,跟int i对齐
```

你可以给foo2这么写:
```c
struct foo2{  
	int i;  
	char c1;  
	char c2;  
	char c3; 
};  
```
再编译执行下会发现结果不变, 大小还是8.这说明对齐确实存在.再追加一个c4,foo2大小还是为8

## 8.function(void)与function()的区别

看下面代码的编译结果
```c
void foo1(){}
void foo2(void){}
main()
{
	foo1(1); 
	foo2(1); 
}
```
编译:
```
1.c: In function ‘main’:
1.c:6:2: error: too many arguments to function ‘foo2’
1.c:2:6: note: declared here
```
function(void)是严格的表示它没有参数

function()是指参数类型未知

